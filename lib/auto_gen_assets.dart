library auto_gen_assets;

import 'dart:io';

class AssetGenerator {
  final String assetsDirectory;
  final String outputFile;
  final String className;
  final bool ignoreHiddenFiles;
  final bool ignoreEnvFiles;

  AssetGenerator({
    this.assetsDirectory = 'assets',
    this.outputFile = 'lib/generated/assets.dart',
    this.className = 'Assets',
    this.ignoreHiddenFiles = true,
    this.ignoreEnvFiles = true,
  });

  bool generate() {
    final assetsDir = Directory(assetsDirectory);
    final output = File(outputFile);
    final buffer = StringBuffer();

    if (!assetsDir.existsSync()) {
      print('‚ùå Directory not found: $assetsDirectory');
      return false;
    }

    final Map<String, List<_AssetItem>> grouped = {};
    final allFiles = assetsDir
        .listSync(recursive: true)
        .whereType<File>()
        .where((file) {
          final name = file.uri.pathSegments.last;
          if (ignoreHiddenFiles && name.startsWith('.')) return false;
          if (ignoreEnvFiles && name.contains('.env')) return false;
          return true;
        })
        .toList();

    for (var file in allFiles) {
      final path = file.path.replaceAll('\\', '/');
      final parts = path.split('/');
      if (parts.length < 3) continue;
      final folder = parts[1];
      grouped
          .putIfAbsent(folder, () => [])
          .add(
            _AssetItem(
              name: _toCamelCase(parts.last.split('.').first),
              path: path,
            ),
          );
    }

    buffer.writeln('///This file is automatically generated. DO NOT EDIT.');
    buffer.writeln('class $className {');
    buffer.writeln('  $className._();\n');
    grouped.forEach((folder, items) {
      final className = _toPascalCase(folder);
      buffer.writeln('  static const $className $folder = $className();');
    });
    buffer.writeln('}\n');

    grouped.forEach((folder, items) {
      final className = _toPascalCase(folder);
      buffer.writeln('class $className {');
      buffer.writeln('  const $className();');
      for (var item in items) {
        buffer.writeln("  final String ${item.name} = '${item.path}';");
      }
      buffer.writeln('}\n');
    });

    output.createSync(recursive: true);
    output.writeAsStringSync(buffer.toString());
    return true;
  }
}

class _AssetItem {
  final String name;
  final String path;
  _AssetItem({required this.name, required this.path});
}

String _toPascalCase(String text) => text
    .split(RegExp(r'[_\-\s]+'))
    .map((w) => w.isNotEmpty ? '${w[0].toUpperCase()}${w.substring(1)}' : '')
    .join();

String _toCamelCase(String text) {
  final parts = text.split(RegExp(r'[_\-\s]+'));
  if (parts.isEmpty) return '';
  final first = parts.first.toLowerCase();
  final rest = parts
      .skip(1)
      .map((w) => w[0].toUpperCase() + w.substring(1))
      .join();
  return '$first$rest';
}
